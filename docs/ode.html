<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>C++ Playground for Numerical Integration Method Developers</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="css/my.css" media="all"></link><link rel="stylesheet" href="js/katex/katex.min.css" media="all"></link><link rel="stylesheet" href="css/jquery.fancybox.min.css" media="all"></link><link rel="stylesheet" href="css/clock.css" media="all"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="c-playground-for-numerical-integration-method-developers">C++ Playground for Numerical Integration Method Developers</h1><h2 id="s-g-orlov">S.G. Orlov</h2><h3 id="computer-technologies-in-engineering-dept">Computer technologies in engineering dept.</h3><h3 id="peter-the-great-st-petersburg-polytechnic-university">Peter the Great St. Petersburg Polytechnic University</h3><p class="conference-subtitle">Russian Supercomputing Days <br />
Sept. 25-26 2017, Moscow, Russia</p><p><a href="https://deadmorous.github.io/rsd-2017/ode.html">deadmorous.github.io/rsd-2017/ode.html</a></p><img src="images/qr/qr-code-ode.jpg" class="qr-code-in-title"></img></div><div class="step step-level-1" step="1" data-x="1400" data-scale="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-y="0" data-z="0"><h1 id="outline">Outline</h1><ul><li>ODEs with additional discrete state<ul><li>Considering initial value problem (IVP)</li></ul></li><li>Why create yet another framework?</li><li>The <span class="tt">ode_num_int</span> framework<ul><li>Common infrastructure</li><li>Linear algebra</li><li>Nonlinear algebraic Newton-type solver</li><li>ODE Solvers</li><li>Code example</li><li>Problems &amp; future work</li></ul></li><li>Conclusions</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="2800" data-y="0" data-z="0"><h1 id="odes-with-discrete-state">ODEs with discrete state</h1><p>$\dot{\bf x} = {\bf f}(t, {\bf x}, \phi), \quad {\bf x}\bigr|_{t=t_0}={\bf x}_0, \quad \phi\bigr|_{t=t_0}=\phi_0$</p><ul><li>${\bf x}=[x_1, \ldots, x_n]^T$ &#x2014; state vector</li><li>$t$ &#x2014; time</li><li>${\bf f}$ &#x2014; ODE right hand side</li><li>$\phi=[\phi_1, \ldots, \phi_m]^T$ &#x2014; <span class="definition">discrete state variables</span></li><li>${\bf x}$ and $\phi$ may change at $t_s$, when an <span class="definition">event</span> occurs:</li></ul><p>$t_s: \quad e_k(t_s, {\bf x}, \phi) = 0, \quad k=1, \ldots, n_e, \quad s=1,2,\ldots$</p><ul><li>$e_k(t, {\bf x}, \phi)$ &#x2014; <span class="definition">event indicator</span> functions</li></ul></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4200" data-y="0" data-z="0"><h1 id="id2">ODEs with discrete state</h1><p>An example of evolution of system with discrete state</p><img src="images/ode_num_int_events.png" width="600px"></img><p>more: Functional Mock-up Interface 2.0</p><span style="display: block; line-height: 20px; margin-top: -10px;">
<a href="https://svn.modelica.org/fmi/branches/public/specifications/v2.0/FMI_for_ModelExchange_and_CoSimulation_v2.0.pdf#page=69" class="smaller-60" target="_blank">
   svn.modelica.org/fmi/branches/public/specifications/v2.0/<br/>FMI_for_ModelExchange_and_CoSimulation_v2.0.pdf (p. 69)
</a>
</span></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="5600" data-y="0" data-z="0"><h1 id="why-another-framework">Why another framework?</h1><div class="smaller-85"><ul><li>What we want<ul><li>Construct ODE IVP solvers from smallest building blocks</li><li>C++</li><li>Reasonably fast code</li><li>Convenient linear algebra interface<ul><li>Avoid copying when possible</li><li>Use a parallel LA library when necessary</li></ul></li><li>Easily extensible system (high level of code reuse)</li><li>Run test cases<ul><li>Configure solver at run time</li><li>Measure timings &amp; monitor whatever we need</li><li>Flexible output control</li><li>ODE system sizes up to ~10000</li></ul></li><li><span class="almost-invisible">&#x41C;&#x43E;&#x436;&#x43D;&#x43E; &#x433;&#x440;&#x430;&#x431;&#x438;&#x442;&#x44C; &#x43A;&#x43E;&#x440;&#x43E;&#x432;&#x430;&#x43D;&#x44B;</span></li></ul></li></ul></div></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="7000" data-y="0" data-z="0"><h1 id="id3">Why another framework?</h1><div class="smaller-95"><ul><li>What is available<ul><li>Environments for numerical computing: <br /> <a href="https://www.mathworks.com/products/matlab.html">MATLAB</a>, <a href="http://www.scilab.org/">Scilab</a>, <a href="https://www.gnu.org/software/octave/">GNU Octave</a>, <a href="http://www.euler-math-toolbox.de/index.html">Euler</a>, etc. <span class="notice">(too slow)</span></li><li>ODE IVP codes<ul><li>FORTRAN &amp; C: <a href="_http://www.mcs.anl.gov/petsc/">PETSc</a>, <a href="http://www.netlib.org/ode/index.html">Netlib ode</a>, <a href="https://www.nag.com/numeric/fl/nagdoc_fl26/html/d02/d02conts.html">NAG D02</a>, <a href="http://www.hsl.rl.ac.uk/">HSL</a>, <a href="http://gams.nist.gov/cgi-bin/serve.cgi/Package/CMLIB">CMLIB</a>,
<a href="http://www.radford.edu/~thompson/vodef90web/">VODE_F90</a>, <a href="https://computation.llnl.gov/projects/sundials">SUNDIALS</a>, <a href="http://www.unige.ch/~hairer/software.html">Codes by Hairer, N&#xF8;rsett, Wanner</a>,
<a href="http://dumkaland.org/">DUMKA3</a>, etc.</li><li>C++: <a href="http://www.boost.org/doc/libs/1_65_1/libs/numeric/odeint/doc/html/index.html">Boost.Numeric.Odeint</a></li></ul></li><li>Linear algebra codes<ul><li>FORTRAN &amp; C: <a href="http://www.netlib.org/lapack/">LAPACK</a>, <a href="http://faculty.cse.tamu.edu/davis/suitesparse.html">SuiteSparse</a>, etc.</li><li>C++: <a href="http://arma.sourceforge.net/">Armadillo</a>, <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>, <a href="http://blitz.sourceforge.net/">Blitz++</a>,
<a href="http://www.simunova.com/mtl4">MTL4</a>, <a href="http://itpp.sourceforge.net/4.3.1/index.html">IT++</a>, <a href="http://math.nist.gov/tnt/index.html">TNT</a>, etc.</li></ul></li></ul></li></ul></div></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8400" data-y="0" data-z="0"><h1 id="id4">Why another framework?</h1><div class="smaller-90"><ul><li>Can't we just use above ODE IVP codes?<ul><li><a href="https://computation.llnl.gov/projects/sundials">SUNDIALS</a><ul><li>Implements a few solvers for ODE, DAE, ...</li><li><span class="midgreen">Supports events</span></li></ul></li><li><a href="http://www.boost.org/doc/libs/1_65_1/libs/numeric/odeint/doc/html/index.html">Boost.Numeric.Odeint</a><ul><li><span class="midgreen">Many ODE solvers</span></li><li><span class="notice">No event support</span></li></ul></li><li>All<ul><li><span class="notice">Too large building blocks</span></li><li><span class="notice">Difficult to implement new solver</span></li><li><span class="notice">Few means for monitoring</span></li><li><span class="critical">Designed for solver users, not solver developers</span></li></ul></li></ul></li></ul></div></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9800" data-y="0" data-z="0"><h1 id="id5">Why another framework?</h1><ul><li>There are basic ideas in software engineering<ul><li>divide &amp; conquer, separation of concerns, single responsibility principle</li><li>OOP: interfaces, encapsulation, polymorphism</li><li>design patterns</li></ul></li><li>Existing numerical codes often<ul><li>are not OO</li><li>disregard divide &amp; conquer</li><li>employ awkward design patterns</li><li>are not in C++</li><li><span class="notice">that is sad</span></li></ul></li></ul></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="id6">Why another framework?</h1><ul><li>Attempts to provide C++ codes &amp; wrappers often<ul><li>do not use the power of C++ and are inefficient<ul><li>e.g. <a href="http://itpp.sourceforge.net/4.3.1/index.html">IT++</a></li></ul></li><li>are just outdated &amp; unsupported<ul><li>e.g. <a href="http://lapackpp.sourceforge.net/">LAPACK++</a> (2012), <a href="http://blitz.sourceforge.net/">Blitz++</a> (2011), <a href="http://math.nist.gov/tnt/index.html">TNT</a> (2004)</li></ul></li><li><span class="notice">C++ codes worse than others - that is desperate</span></li></ul></li><li><span class="midgreen">Still there are great things!</span><ul><li>e.g., <a href="http://arma.sourceforge.net/">Armadillo</a>, <a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a>, <a href="http://www.boost.org/doc/libs/1_65_1/libs/numeric/odeint/doc/html/index.html">Boost.Numeric.Odeint</a></li></ul></li><li><span class="orange">Homemade vectors &amp; matrices everywhere!</span></li></ul></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12600" data-y="0" data-z="0"><h1 id="new-framework-ode-num-int">New framework: <span class="tt">ode_num_int</span></h1><p class="remove-margin-bottom remove-margin-top">Common infrastructure</p><div class="smaller-75 remove-list-margin-top"><ul><li><a href="ode-code-samples.html#/step-2">observers</a><ul><li>to provide basic means for monitoring everything</li><li>similar to <a href="http://www.boost.org/doc/libs/1_65_1/doc/html/signals2.html">Boost.Signals2</a> but simpler &amp; faster</li></ul></li><li><a href="ode-code-samples.html#/step-3">property holder</a><ul><li>to define uniform rules for component / parameter aggregation</li><li>class storing a single private field of specified type</li><li>has public getter &amp; setter &amp; notifier</li></ul></li><li><a href="ode-code-samples.html#/step-4">factory</a><ul><li>to dynamically create instances</li></ul></li><li><a href="ode-code-samples.html#/step-5">optional parameters</a><ul><li>to organize trees of values of any type</li><li>interop. with factories &#x2014; easy to I/O objects</li></ul></li><li><a href="ode-code-samples.html#/step-6">timing utilities</a><ul><li>to measure CPU time spent in a block of code</li></ul></li></ul></div></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14000" data-y="0" data-z="0"><h1 id="linear-algebra">Linear algebra</h1><div class="smaller-85"><ul><li>Vectors &amp; sparse matrices design<ul><li>storage &amp; element access rules defined by template parameter</li><li>helps avoid copying by providing<ul><li><span class="definition">proxies</span> for subvector, submatrix, transposed or scaled matrix<ul><li><span class="definition">views</span> in other software are similar</li><li>but our proxies are vectors &amp; matrices too <br /> $\Rightarrow$ simpler design</li></ul></li><li>move constructors</li></ul></li><li>iterators for using <span class="tt">std</span> algorithms</li><li>matrices with flexible sparsity pattern (slower)</li><li>matrices with fixed sparsity pattern (faster)</li></ul></li><li>Sparse LU</li></ul></div></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="15400" data-y="0" data-z="0"><h1 id="la-example">LA example</h1><div class="smaller-75"><pre class="highlight code C++"><span class="c1">// note: SparseMatrix&lt;T&gt; = SparseMatrixTemplate&lt; SparseMatrixData&lt; T &gt; &gt;;
</span><span class="n">SparseMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>     <span class="c1">//        2 0 0 0 0
</span><span class="n">a</span><span class="p">.</span><span class="n">addScaledIdentity</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>         <span class="c1">//        1 2 0 0 0
</span><span class="n">a</span><span class="p">.</span><span class="n">block</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">).</span><span class="n">addIdentity</span><span class="p">();</span>  <span class="c1">// a  &lt;-  0 1 2 0 0
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>                <span class="c1">//        0 0 1 2 0
</span>                                  <span class="c1">//        0 0 0 1 2
</span>
<span class="n">a</span> <span class="o">*=</span> <span class="n">a</span><span class="p">.</span><span class="n">transposed</span><span class="p">();</span>              <span class="c1">//        5 2 0 0 0
</span><span class="n">a</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>                   <span class="c1">//        2 5 2 0 0
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>                <span class="c1">// a  &lt;-  0 2 5 2 0
</span>                                  <span class="c1">//        0 0 2 5 2
</span>                                  <span class="c1">//        0 0 0 2 5
</span>
<span class="c1">// note: Vector&lt;T&gt; = VectorTemplate&lt; VectorData&lt; T &gt; &gt;;
</span><span class="n">Vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>              <span class="c1">//
</span><span class="n">fill</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">b</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>      <span class="c1">// b  &lt;- [1 1 1 1 1]'
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>                <span class="c1">//
</span>
<span class="c1">// Solve a*x = b
</span><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>                       <span class="c1">// x  &lt;-  [0.169231,  0.0769231, 0.138462,
</span><span class="n">LUFactorizer</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">).</span><span class="n">solve</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">//         0.0769231, 0.169231]'
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="c1">// Check residual
</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b</span><span class="p">).</span><span class="n">euclideanNorm</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>    <span class="c1">// 1.11022e-016</span></pre></div></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16800" data-y="0" data-z="0"><h1 id="nonlinear-algebraic-solver">Nonlinear algebraic solver</h1><div class="smaller-90"><p>${\bf f}({\bf x})=0, \quad {\bf x}_{n+1} = {\bf x}_n + \alpha_n {\bf d}_n, \quad {\bf A}{\bf d}_n = - {\bf f}({\bf x}_n), \quad {\bf A}\approx \left.\frac{D {\bf f}}{D {\bf x}}\right|_{{\bf x}={\bf x}_n}$</p></div><div class="smaller-85"><ul><li>To build an efficient Newton-type solver one may need to choose<ul><li>appropriate vector norm for residual</li><li>stopping criterion</li><li>Jacobian evaluation &amp; update algorithms</li><li>line search algorithm</li><li>regularization strategy</li><li>iteration algorithm</li></ul></li><li><span class="tt">ode_num_int</span> provides abstractions for minimal building blocks<ul><li>developer can concentrate on one separate thing</li><li>solver is easily built from separate components</li><li>one or several implementations for each component</li></ul></li></ul></div></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="18200" data-y="0" data-z="0"><h1 id="abstractions-for-newton-solver"><span class="smaller-90">Abstractions for Newton solver</span></h1><div class="smaller-80"><ul><li><span class="tt">VectorMapping</span> &#x2014; compute ${\bf f}({\bf x})$ or ${\bf f}({\bf x}, \gamma)$</li><li><span class="tt">ErrorEstimator</span> &#x2014; compute residual norm, judge about convergence</li><li><span class="tt">NewtonDescentDirection</span> &#x2014; compute descent direction ${\bf d}_n$<ul><li>holds <span class="tt">JacobianProvider</span> &#x2014; compute sparse Jacobian<ul><li>holds <span class="tt">JacobianTrimmer</span> (optional) &#x2014; simplify sparsity pattern</li></ul></li></ul></li><li><span class="tt">NewtonLinearSearch</span> &#x2014; choose a point along descent dir. &#x2014; compute $\alpha_n$</li><li><span class="tt">NewtonIterationPerformer</span> &#x2014; compute ${\bf x}_{n+1}$ and return status<ul><li>holds all above components</li></ul></li><li><span class="tt">NewtonRegularizationStrategy</span> &#x2014; manage regularization parameter $\gamma$: ${\bf f}({\bf x}) = {\bf g}({\bf x}, \gamma)|_{\gamma=0}$<ul><li>holds <span class="tt">VectorMappingRegularizer</span> &#x2014; compute ${\bf g}({\bf x}, \gamma)$</li></ul></li><li><span class="tt">NewtonSolverInterface</span> &#x2014; solve nonlinear equation, report status<ul><li>holds <span class="tt">NewtonIterationPerformer</span> and <span class="tt">NewtonRegularizationStrategy</span></li></ul></li></ul></div></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19600" data-y="0" data-z="0"><h1 id="newtondescentdirection-implementations-matter"><span class="tt">NewtonDescentDirection</span> implementations matter</h1><img src="images/ode_num_int/descent-dir-stuff.png" height="400px"></img><p class="smaller-75"><span class="orange">100x difference in performance is well possible</span> (in terms of number of ${\bf f}({\bf x})$ evaluations,
${\bf LU}$ decompositions, ${\bf LU}$ solves,
and in terms of CPU time)</p></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="21000" data-y="0" data-z="0"><h1 id="ode-solvers-abstractions">ODE solvers: abstractions</h1><div class="smaller-85"><ul><li><span class="tt">OdeRhs</span> &#x2014; ODE system definition<ul><li>compute ${\bf f}(t, {\bf x}, \varphi)$ or e.g. ${\bf f}(t, {\bf x}, \dot{\bf x}, {\bf z}, \varphi, \gamma)$<ul><li>support for 2nd order ODE, dependency on time &amp; params</li></ul></li><li>compute event indicators $e_k(t, {\bf x}, \phi)$</li><li>implement phase state changes</li></ul></li><li><span class="tt">OdeSolver</span> &#x2014; solve ODE system, maybe with events<ul><li>holds <span class="tt">OdeRhs</span></li><li>optionally holds<ul><li><span class="tt">OdeSolverErrorNormCalculator</span> &#x2014; compute vector norm</li><li><span class="tt">OdeStepSizeController</span> &#x2014; conrol step size <br /> for embedded time steppers</li><li><span class="tt">OdeEventController</span> &#x2014; detect events, truncate steps, change $\phi$</li></ul></li></ul></li></ul></div></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="explicit-ode-solvers">Explicit ODE solvers</h1><img src="images/ode_num_int/ode-solvers-explicit.png" width="843px"></img><ul><li>Common schemes (explicit Euler, RK4, DOPRI, Gragg)<ul><li>Others easily obtained by providing Butcher tableau</li></ul></li><li>Richardson extrapolator<ul><li>uses any reference solver &amp; step sequence</li><li>e.g., GBS method is easily constructed w/o coding</li></ul></li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="23800" data-y="0" data-z="0"><h1 id="implicit-ode-solvers">Implicit ODE solvers</h1><img src="images/ode_num_int/ode-solvers-implicit.png" width="400px"></img><div class="smaller-80"><ul><li>Linearly implicit<ul><li>Rosenbrock SW2-4 (embedded) by <a href="https://www.researchgate.net/publication/265703102_An_Attempt_to_Avoid_Exact_Jacobian_and_Nonlinear_Equations_in_the_Numerical_Solution_of_Stiff_Differential_Equations">Steihaug &amp; Wolfbrandt</a></li><li>Rosenbrock W1:
${\bf x}_{n+1} = {\bf x}_n + h {\bf k}, \quad {\bf W} {\bf k} = {\bf f}(t_n, {\bf x}_n), \quad {\bf W} = {\bf I} - hd {\bf A}, \quad {\bf A} \approx \frac{D{\bf f}}{D{\bf x}}$</li></ul></li><li>Completely explicit<ul><li>Modified Euler<ul><li>${\bf x}_{n+1} = {\bf x}_n + h[(1-\alpha){\bf f}(t_n, {\bf x}_n) + \alpha{\bf f}(t_n+h, {\bf x}_{n+1})]$</li><li>trapezoidal rule at $\alpha=0.5$</li></ul></li></ul></li></ul></div></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25200" data-y="0" data-z="0"><h1 id="ode-solver-helpers">ODE solver helpers</h1><table cellpadding="0" cellspacing="0" class="smaller-90 remove-list-margin-top"><tbody><tr><td><ul><li><span class="tt">OdeSolverOutputOption</span> &#x2014; interface
for objects <br /> collecting solver output<ul><li>new output options can <br /> easily be created</li></ul></li></ul></td><td><img src="images/ode_num_int/ode-solver-output.png" width="500px"></img></td></tr><tr><td colspan="2"><ul><li><span class="tt">OdeSolverConfiguration</span><ul><li>holds parameter set describing<ul><li>ODE specification</li><li>ODE solver with all nested components and parameters</li><li>output specification</li></ul></li></ul></li><li><span class="tt">solveOde</span> &#x2014; solve initial value problem</li></ul></td></tr></tbody></table></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="26600" data-y="0" data-z="0"><h1 id="code-example">Code example</h1><table cellpadding="0" cellspacing="0" class="center-align-table full-width-table"><tbody><tr><td><div class="smaller-60"><pre class="highlight code C++"><span class="cp">#include</span> <span class="cpf">"ode_num_int/OdeSolverConfiguration.h"</span><span class="cp">
#include</span> <span class="cpf">"reg.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">ctm</span><span class="p">;</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">math</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">VectorData</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">VD</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">VectorTemplate</span><span class="o">&lt;</span><span class="n">VD</span><span class="o">&gt;</span> <span class="n">V</span><span class="p">;</span>

    <span class="n">registerTypes</span><span class="p">();</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="n">OdeSolverConfiguration</span><span class="o">&lt;</span><span class="n">VD</span><span class="o">&gt;</span> <span class="n">cfg</span><span class="p">;</span>
        <span class="n">cfg</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="s">"rhs"</span><span class="p">,</span> <span class="s">"bouncing_ball"</span><span class="p">);</span>
        <span class="n">cfg</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="s">"rhs.stick_speed"</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">);</span>
        <span class="n">cfg</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="s">"output_con"</span><span class="p">,</span> <span class="s">"con_solution"</span><span class="p">);</span>
        <span class="n">cfg</span><span class="p">.</span><span class="n">setValue</span><span class="p">(</span><span class="s">"time"</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

        <span class="n">V</span> <span class="n">x0</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
        <span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">;</span>
        <span class="k">auto</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">.</span><span class="n">apply</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x0</span> <span class="p">);</span>
        <span class="n">solveOde</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">cfg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sc</span> <span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"ERROR: "</span> <span class="o">&lt;&lt;</span> <span class="n">e</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></pre></div></td><td><p class="smaller-60">output:</p><pre class="highlight smaller-60">time      x0      v0
0 0.5     0
0.01      0.49951 -0.098
0.02      0.49804 -0.196
0.03      0.49559 -0.294
0.04      0.49216 -0.392
0.05      0.48775 -0.49
0.06      0.48236 -0.588
0.07      0.47599 -0.686
...</pre><img src="images/ode_num_int/bouncing-ball-output.png" width="400px"></img></td></tr></tbody></table></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28000" data-y="0" data-z="0"><h1 id="id7">Code example</h1><div class="scrollable-code height-550 smaller-55"><pre class="highlight code C++"><span class="k">template</span><span class="o">&lt;</span> <span class="k">class</span> <span class="nc">VD</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">BouncingBall</span> <span class="o">:</span>
    <span class="k">public</span> <span class="n">OdeRhs</span><span class="o">&lt;</span> <span class="n">VD</span> <span class="o">&gt;</span><span class="p">,</span>
    <span class="k">public</span> <span class="n">FactoryMixin</span><span class="o">&lt;</span> <span class="n">BouncingBall</span><span class="o">&lt;</span><span class="n">VD</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">OdeRhs</span><span class="o">&lt;</span><span class="n">VD</span><span class="o">&gt;</span> <span class="o">&gt;</span>
    <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">typedef</span> <span class="n">VectorTemplate</span><span class="o">&lt;</span> <span class="n">VD</span> <span class="o">&gt;</span> <span class="n">V</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="k">typename</span> <span class="n">V</span><span class="o">::</span><span class="n">value_type</span> <span class="n">real_type</span><span class="p">;</span>
        <span class="k">typedef</span> <span class="n">OptionalParameters</span><span class="o">::</span><span class="n">Parameters</span> <span class="n">Parameters</span><span class="p">;</span>

        <span class="k">enum</span> <span class="n">FrictionType</span> <span class="p">{</span> <span class="n">Atan</span><span class="p">,</span> <span class="n">Tabular</span><span class="p">,</span> <span class="n">Linear</span> <span class="p">};</span>

        <span class="k">explicit</span> <span class="nf">BouncingBall</span><span class="p">()</span> <span class="o">:</span>
            <span class="n">m_g</span><span class="p">(</span> <span class="mf">9.8</span> <span class="p">),</span>
            <span class="n">m_recoveryFactor</span><span class="p">(</span> <span class="mf">0.9</span> <span class="p">),</span>
            <span class="n">m_stickSpeed</span><span class="p">(</span> <span class="mf">1e-5</span> <span class="p">),</span>
            <span class="n">m_sticking</span><span class="p">(</span> <span class="nb">false</span> <span class="p">)</span>
            <span class="p">{}</span>

        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">secondOrderVarCount</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">firstOrderVarCount</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">zeroFuncCount</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">zeroFuncFlags</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="n">OdeRhs</span><span class="o">&lt;</span><span class="n">VD</span><span class="o">&gt;::</span><span class="n">PlusMinus</span> <span class="p">);</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">rhs</span><span class="p">(</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="n">real_type</span> <span class="n">time</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">x</span> <span class="p">)</span> <span class="k">const</span>
            <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">odeRhsPreObservers</span><span class="p">(</span> <span class="n">time</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="k">this</span> <span class="p">);</span>
            <span class="n">dst</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="mi">2</span> <span class="p">);</span>
            <span class="k">if</span><span class="p">(</span> <span class="n">m_sticking</span> <span class="p">)</span>
                <span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">dst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">m_g</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">odeRhsPostObservers</span><span class="p">(</span> <span class="n">time</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="k">this</span> <span class="p">);</span>
            <span class="p">}</span>

        <span class="kt">void</span> <span class="n">zeroFunctions</span><span class="p">(</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">dst</span><span class="p">,</span> <span class="n">real_type</span> <span class="cm">/*time*/</span><span class="p">,</span> <span class="k">const</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">x</span> <span class="p">)</span> <span class="k">const</span>
            <span class="p">{</span>
            <span class="n">dst</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span> <span class="mi">1</span> <span class="p">);</span>
            <span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="p">}</span>

        <span class="kt">void</span> <span class="n">switchPhaseState</span><span class="p">(</span> <span class="k">const</span> <span class="kt">int</span><span class="o">*</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">real_type</span> <span class="cm">/*time*/</span><span class="p">,</span> <span class="n">V</span><span class="o">&amp;</span> <span class="n">x</span> <span class="p">)</span>
            <span class="p">{</span>
            <span class="k">auto</span> <span class="n">stick</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">this</span><span class="p">]()</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">m_sticking</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="p">};</span>

            <span class="k">if</span><span class="p">(</span> <span class="n">fabs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">m_stickSpeed</span> <span class="p">)</span>
                <span class="n">stick</span><span class="p">();</span>
            <span class="k">else</span> <span class="nf">if</span><span class="p">(</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Falling down, there was no collision just a moment before
</span>                <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="n">m_recoveryFactor</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="k">else</span>
                <span class="c1">// There was a collision just a moment before, because the speed is positive.
</span>                <span class="c1">// If we let the point go up, there will be a collision again because at the end of
</span>                <span class="c1">// next time step the point will be below the plane again, just as it is now.
</span>                <span class="c1">// As a result, there will be an infinite loop.
</span>                <span class="c1">// Therefore, the best we can do now is to consider the point stick to the plane.
</span>                <span class="n">stick</span><span class="p">();</span>
            <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">describeZeroFunction</span><span class="p">(</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="cm">/*index*/</span> <span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">"Height of the point over the plane"</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="n">Parameters</span> <span class="n">parameters</span><span class="p">()</span> <span class="k">const</span>
            <span class="p">{</span>
            <span class="n">Parameters</span> <span class="n">result</span><span class="p">;</span>
            <span class="n">result</span><span class="p">[</span><span class="s">"gravity_acceleration"</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_g</span><span class="p">;</span>
            <span class="n">result</span><span class="p">[</span><span class="s">"recovery_factor"</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_recoveryFactor</span><span class="p">;</span>
            <span class="n">result</span><span class="p">[</span><span class="s">"stick_speed"</span><span class="p">]</span> <span class="o">=</span> <span class="n">m_stickSpeed</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="kt">void</span> <span class="n">setParameters</span><span class="p">(</span> <span class="k">const</span> <span class="n">Parameters</span> <span class="o">&amp;</span> <span class="n">parameters</span> <span class="p">)</span>
            <span class="p">{</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">maybeLoadParameter</span><span class="p">(</span> <span class="n">parameters</span><span class="p">,</span> <span class="s">"gravity_acceleration"</span><span class="p">,</span> <span class="n">m_g</span> <span class="p">);</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">maybeLoadParameter</span><span class="p">(</span> <span class="n">parameters</span><span class="p">,</span> <span class="s">"recovery_factor"</span><span class="p">,</span> <span class="n">m_recoveryFactor</span> <span class="p">);</span>
            <span class="k">this</span><span class="o">-&gt;</span><span class="n">maybeLoadParameter</span><span class="p">(</span> <span class="n">parameters</span><span class="p">,</span> <span class="s">"stick_speed"</span><span class="p">,</span> <span class="n">m_stickSpeed</span> <span class="p">);</span>
            <span class="p">}</span>

        <span class="n">Parameters</span> <span class="n">helpOnParameters</span><span class="p">()</span> <span class="k">const</span>
            <span class="p">{</span>
            <span class="n">Parameters</span> <span class="n">result</span><span class="p">;</span>
            <span class="n">result</span><span class="p">[</span><span class="s">"gravity_acceleration"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Gravity acceleration"</span><span class="p">;</span>
            <span class="n">result</span><span class="p">[</span><span class="s">"recovery_factor"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Impact recovery factor"</span><span class="p">;</span>
            <span class="n">result</span><span class="p">[</span><span class="s">"stick_speed"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Normal speed threshold for sticking"</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
            <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">helpOnType</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="s">"Point falling onto a horizontal plane under the gravity force.</span><span class="se">\n</span><span class="s">"</span>
                   <span class="s">"Point-plane collision leads to an impact, so the point is reflected;</span><span class="se">\n</span><span class="s">"</span>
                   <span class="s">"its impulse decreases according to a recovery factor."</span><span class="p">;</span>
            <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">real_type</span> <span class="n">m_g</span><span class="p">;</span>
        <span class="n">real_type</span> <span class="n">m_recoveryFactor</span><span class="p">;</span>
        <span class="n">real_type</span> <span class="n">m_stickSpeed</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="n">m_sticking</span><span class="p">;</span>
    <span class="p">};</span></pre></div></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="29400" data-y="0" data-z="0"><h1 id="problems-future-work">Problems &amp; future work</h1><div class="smaller-80"><ul><li><span class="notice">Dev. docs still missing</span>, sorry for that</li><li>Old school runtime polymprphism<ul><li>needed for configuring solvers at run time</li><li><span class="notice">doesn't play well with templates</span><ul><li>extra data copying may happen</li><li>workarounds are possible</li></ul></li></ul></li><li>Build ecosystem needs to be set up to involve more people<ul><li>unit tests</li><li>continuous integration</li></ul></li><li>Would be nice to have<ul><li>embedded scripting environment (e.g. JavaScript)</li><li>common tools (e.g. stability region calculator)</li><li>faster vectors &amp; matrices<ul><li>expression templates, <span class="tt">BLAS</span>, <span class="tt">SparseSuite</span>, better move semantics</li></ul></li></ul></li></ul></div></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30800" data-y="0" data-z="0"><h1 id="conclusions">Conclusions</h1><ul><li>New framework <span class="tt">ode_num_int</span><ul><li>open source, GNU GPL 3.0 license<ul><li><a href="https://github.com/deadmorous/ode_num_int">github.com/deadmorous/ode_num_int</a></li></ul></li><li>written in C++11</li><li>for ODE numerical integration method developers</li><li>smallest building blocks<ul><li>easy to extend</li><li>high level of code reuse</li></ul></li><li>good (suboptimal) performance</li><li>successfully used for real life application</li><li>There are things to do</li></ul></li></ul></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32200" data-y="0" data-z="0"><h1 id="thank-you">Thank you</h1><h2 id="questions">Questions?</h2></div></div><div id="hovercraft-help" class="hide"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script><script type="text/javascript" src="js/jquery-3.2.0.min.js"></script><script type="text/javascript" src="js/jquery.fancybox-mod.js"></script><script type="text/javascript" src="js/slide-transitions.js"></script><script type="text/javascript" src="js/katex/katex.min.js"></script><script type="text/javascript" src="js/katex/contrib/auto-render.min.js"></script><script type="text/javascript" src="js/rendermath.js"></script><script type="text/javascript" src="js/clock.js"></script></body></html>
